자바 면접 리스트 지순 정리 <br>
Q1. 자바의 특징과 장단점 <br>
특징 <br>
- 객체 지향 언어
- 자바 가상 머신을 사용해 동작하기 때문에 플랫폼 독립적
장점 <br>
- 플랫폼 독립적
  - JVM만 있으면 하드웨어 운영체제와 상관없이 자바프로그램 실행 가능
- 멀티 스레드
  - C, C++등의 언어들은 멀티 스레드를 지원하지 않고 운영체제의 도움을 받지만 자바에서는 Thread API를 제공하면서 운영체제에 종속되지 않고 독립적으로 실행 가능하다.
단점 <br>
- 실행 속도
  - JVM에 의해 기계어로 번역되고 실행되서 컴파일되자마자 기계어로 변환되는 C, C++에 비해 속도가 떨어진다.
<br>

Q2. 객체 지향 언어의 정의와 장단점 <br>
장점 <br>
  * 재사용성이 높아져 생산성이 향상된다.<br>
단점 <br>
  * 상대적으로 실행속도가 느리다. 
  <br><br>

Q3. 클래스란 <br>
  객체를 만들어내기 위한 설계도로 객체의 속성과 행동을 포함한다. 
  <br><br>
 
Q4. 객체란 <br>
  클래스로 만들어낸 실체, 인스턴스라고도 부른다. 
  <br><br>

Q5. 생성자란 <br>
  객체가 생성될 때 초기화를 위한 메소드로 클래스명과 이름이 동일하다. 
  <br><br>

Q6. 지역변수, 인스턴스 변수 ❓ <br>
  * 지역변수: 특정한 구역({ })안에 생성되어 그 지역에만 사용할수 있는 변수
  * 인스턴스 변수(non-static 변수): 클래스 내에 선언된 변수, 객체 생성 시마다 매번 새로운 변수가 생성됨, 클래스 변수와 달리 공유되지 않음
  * 클래스 변수(static 변수): 클래스 내에 선언된 static 변수, JVM이 실행되서 메모리에 올라갈때부터 프로그램 종료될때까지 유지된다. 클래스가 여러 번 생성되어도 static 변수는 처음 딱 한 번만 생성되며 동일한 클래스의 모든 객체들에 의해서 공유됨
  <br><br>

Q7. 오버라이딩, 오버로딩의 차이 <br>
  * 오버라이딩: 부모 클래스가 가지고 있는 메서드를 자식 클래스가 재정의해서 사용
  * 오버로딩: 같은 이름의 메서드를 서로 다르게 동작하도록 여러개로 정의한다. 매개 변수의 유형과 개수를 다르게 하여 호출한다. <br><br>

Q8. 접근 제어자 <br>
  생성자와 멤버에서는 4개다 사용가능하지만 클래스에서는 public과 default만 가용가능하다.
  * public: 제한 없음
  * protected: 해당 클래스, 패키지, 자식 클래스의 멤버에서 접근가능, 다른 패키지의 자손클래스에서도 가능하다는 것!
  * default: 해당 패키지에서 접근 가능
  * private: 해당 클래스에서만 접근이 가능
  <br><br>

Q9. 추상클래스, 인터페이스의 차이 <br>
  * 인터페이스: 최고 수준의 추상화 단계, 전부다 추상메소드여야 하는 것. 모든 메소드가 다 추상메소드여야하고, 모든 멤버 변수가 static final이 붙어야한다. implements, has a
  * 추상클래스: 한개 이상의 추상메서드를 가진 클래스. extends 사용, is a 관계
  <br><br>

Q10. collection framework <br>
주요 collection framework로 3가지를 들 수 있다. 여기서 List, Set은 Collection을 상속받는다.  <br>
  * List: 순서가 있는 데이터의 집합으로 중복을 허락한다.
  * Set: 순서가 없는 데이터의 집합으로 중복을 허용하지 않는다.
  * Map: 키와 값이 한 쌍으로 이루어지며 키는 중복을 허락하지 않는다. 
  <br><br>

Q11. OOP의 특징 <br>
  * 추상화: 공통의 속성이나 기능을 묶어 이름을 붙이는 것
  * 다형성: 부모클래스에서 물려받은 함수를 자식 클래스에서 오버라이딩해서 사용되는 것
  * 상속: 상위 개념의 특징을 하위 개념이 물려받는 것. 재사용으로 인해 코드가 줄어든다.
  * 캡슐화: 실제 구현되는 부분을 외부에 드러나지 않도록 캡슐로 감싸는 것
  * 정보와 은닉: 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념
  <br><br>

Q12. OOP의 5대 원칙(SOLID) <br>
  * 단일 책임 원칙(SRP: Single responsibility principle)
    * 모든 Class는 하나의 책임만 가지며, 그 책임은 완전히 캡슐화되어야 함을 일컫는다
  * 개방 폐쇄 원칙(OCP: Open/closed principle)
    * 클래스, 모듈 함수 등의 소프트웨어 개체는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
  * 리스코프 치환 원칙(LSP: Liskov substitution principle)
    * 상속에 대한 개념으로, 부모 Class가 들어갈 자리에 자식 Class를 넣어도 잘 구동되어야 한다.
  * 인터페이스 분리 원칙(ISP: Interface segregation principle)
    * 클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다.
  * 의존관계 역전 원칙(DIP: Dependency inversion principle)
    * 상위 모듈은 하위 모듈에 종속되어서는 안된다. 둘 다 추상화에 의존해야 한다.
    * 추상화는 세부사항에 의존하지 않는다. 세부사항은 추상화에 의해 달라져야 한다.
    * 외부에서 의존성을 주입받아야한다.
  <br><br>

Q13. 객체 지향과 절차 지향 차이 <br>
  * 절차 지향: 작업 순서를 표현한다.
  * 객체 지향: 객체들간의 관계를 표현한다. <br><br>

Q14. getter/setter 사용 이유 ❓ <br>
  * 캡슐화 위해 사용
  * 변수들을 다른 곳에서 노출 되는 것을 제한하기 위해? <br><br>

Q15. non-static vs static <br>
  * static이 먼저 메모리 영역에 저장된다. 따라서 static 멤버들은 non-static 멤버에 접근할 수 없다. 
  * 또한 static 멤버는 해당 클래스의 모든 객체들에게 공유된다. <br><br>

Q16. final <br>
  * final 클래스 - 상속 불가능
  * final 메소드 - 오버라이딩 불가
  * 상수를 선언할때 사용되며 사용 중에 값을 바꿀 수 없다 <br><br>

Q17. Generic ❓ <br>
  * 자료형 타입을 일반화하기 위한 키워드
  <br><br>

Q18. 가비지 컬렉션 <br>
  * JVM의 가비지 컬렉션은 더 이상 사용하지 않는 메모리를 자동으로 반환해준다. 
  * 기존 C나 C++에서는 개발자가 직접 가비지를 반환해야했는데 이를 Java에서는 JVM에서 자동으로 해준다. 
  <br><br>

Q19. String, StringBuilder, StringBuffer ❓ <br>
  * String: 문자열 연산이 적고 멀티쓰레드 환경일 경우
  * StringBuffer: 문자열 연산이 많고 멀티쓰레드 환경일 경우
  * StringBuilder: 동기화를 고려하지 않아도 되는 경우 사용. 문자열 연산이 많고 단일쓰레드일때 사용하는 것이 좋음.
<br><br>
  
Q20. ==, equals() 차이 <br>
  * == 연산자는 비교하려고 하는 대상의 주소값을 비교한다.
  * equals()는 비교하려고 하는 대상의 값을 비교한다. 
  <br><br>
  
Q21. 자바 메모리 영역 ❓ <br>
  * stack, heap, method으로 구분 된다.
  * heap: new 명령으로 만드는 메모리는 힙 영역에 보관, 라이프사이클이 긴 것들이 들어간다.
  * method: 전역변수와 정적 멤버변수(static 변수) 저장.
  * stack: 지역변수, 인자값, 리턴값이 저장이 되는 영역. 즉 메소드 안에서 사용되어지는 값들이 저장.
  <br><br>

Q22. 변수 명명법 ❓ <br>
  * 카멜표기법 - 자바에서 권장됨.
    * 이름에 여러단어를 혼합하여 사용한다면 첫 번째 단어는 소문자, 두 번째 단어부터는 대문자로 시작한다.
  * 스네이크표기법 - 파이썬에서 권장됨
    * 단어 사이를 '_'로 잇는 방법

  
