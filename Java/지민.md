# 자바 면접 질문 리스트 by 지민


### Q1. 자바의 특징과 장단점
<details>
  <summary>답</summary>
  <div>  
    <p>
	    자바는 이식성이 높고, 플랫폼에 종속적이지 않다는 특징을 가지고 있다. 또, 플랫폼에 종속적이지 않기 때문에 웹/모바일/임베디드 등 다양한 분야에 활용될 수 있다.
      <hr>
      장점은 이식성이 높고 JVM으로 실행되기 때문에 플랫폼 종속적이지 않은 점이며, 단점은 JVM으로 실행되기 때문에 실행 속도가 느리다는 점이다.      
	  </p>
  </div>
</details>
    
### Q2. 객체지향 언어의 정의와 장단점
<details>
  <summary>답</summary>
  <div>  
    <p>
	실제 세계의 객체의 상태와 기능을 구체화하고, 그 객체 사이의 상호작용을 통해 프로그램이 실행되도록 작성하는 언어
      <hr>
      재사용성이 높고, 유지보수성이 좋다는 장점이 있다. 절차지향언어와 비교했을 때 속도가 느리다는 단점이 있다.
	  </p>
  </div>
</details>
   
### Q3. 클래스란
<details>
  <summary>답</summary>
  <div>  
    <p>
      실제 세계에 존재하는 객체의 특성을 정의한 것으로, 객체의 설계도나 틀을 의미한다.
	  </p>
  </div>
</details>
   
### Q4. 객체란
<details>
  <summary>답</summary>
  <div>  
    <p>
      실제 세계에 존재하는 것들이다. TV, 컴퓨터, 책, 건물, 사람 등을 모두 객체라고 할 수 있다.<br>
      +프로그램에서의 객체는 클래스로 만들어낸 실체로, 인스턴스라고도 한다.
	  </p>
  </div>
</details>
   
### Q5. 생성자란 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      객체를 생성하기 위한 초기화 함수<br>
      +클래스 명과 이름이 동일
	  </p>
  </div>
</details>
   
### Q6. 지역변수, 인스턴스 변수 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      지역 변수는 블록 내에서 선언된 변수로, 블록 내부에서만 유효하다.<br>
	+<br>
	    블록은 { }로 만들어지는 영역
	    <hr>
	  인스턴스 변수는 클래스 내부에 선언된 변수. 인스턴스가 생성될 때 메모리가 할당됨.<br>
	  클래스 변수는 클래슨 내부에 static으로 선언된 변수로, 모든 인스턴스가 통된 값을 공유함. 클래스가 메모리에 올라갈 때 메모리가 할당됨.<br>
	  또, 클래스가 로딩될 때 생성되어 종료될 때까지(메모리에 한 번만 올라감) 유지된다.
	  </p>
  </div>
</details>
   
### Q7. 오버라이딩, 오버로딩의 차이
<details>
  <summary>답</summary>
  <div>  
    <p>
      오버라이딩은 상속 관계에서 부모의 메소드를 자식의 특성에 맞게 재정의 하는 것이다.<br>
      메소드의 이름, 리턴 타입, 매개변수 {개수, 타입, 순서}가 일치해야 하며,
      부모 메소드보다 접근 지정자는 크거나 같아야 하고, 부모보다 큰 예외는 처리할 수 없다.
      <hr>
      오버로딩은 이름이 같은 메소드를 서로 다르게 동작하도록 여러 개 정의하는 것이다.<br>
      메소드의 이름이 같고, 매개변수가 다르면 된다. 단, 매개변수가 같고 리턴타입이 다른 경우는 오버로딩이 되지 않는다.
	  </p>
  </div>
</details>
   
### Q8. 접근제어자 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      <h4> private </h4>
      private는 선언된 클래스 내부에서만 접근할 수 있다.<br>
      클래스 선언 시 사용 불가/생성자, 멤버 선언 시 사용가능
      <hr>
      <h4> protected </h4>
      protected는 선언된 클래스, 선언된 패키지 내 다른 클래스에서도 접근할 수 있다. 타 패키지이더라도, 상속받은 자식 클래스라면 접근할 수 있다.<br>
	클래스 선언 시 사용 불가/생성자, 멤버 선언 시 사용가능
      <hr>
      <h4> default </h4>
      default는 선언된 클래스, 선언된 패키지 내 다른 클래스에서도 접근할 수 있다.<br>
	  생성자, 멤버 선언 시 사용가능
      <hr>
      <h4> public </h4>
      public은 접근 제한 없이 모든 곳에서 접근할 수 있다.<br>
	  생성자, 멤버 선언 시 사용가능
	  </p>
  </div>
</details>
   
### Q9. 추상클래스, 인터페이스의 차이 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      추상클래스는 멤버 변수와 멤버 함수가 모두 선언만 되고 구현되지 않은 클래스이다. abstract 키워드를 사용하며, 구현의 강제성을 위해 사용한다.<br>
	    +
	    추상 클래스를 상속받아 기능을 이용하고, 확장시키기 위해 사용하며, 클래스이기 때문에 다중 상속 불가능
	    일반메서드와 추상 메서드를 동시에 선언할 수 있다.
	    생성자, 일반 변수 모두 선언 가능하고, 메서드의 부분적인 구현이 가능하다.
	    extends 키워드로 상속할 수 있다.
      <hr>
      인터페이스는 멤버 변수와 멤버 함수가 모두 선언만 되고 구현되지 않은 클래스이다. interface 키워드로 정의하며, 구현의 강제성을 위해 사용한다.<br>
      인터페이스를 상속받은 클래스의 경우, 선언된 모든 메소드를 오버라이딩하여 구현해야한다.
	  +
	  구현 객체의 같은 동작을 보장하기 위해 사용하며, 다중 상속이 가능하다.
	  인터페이스는 최고 수준의 추상화 단게로, 상수와 추상메서드만 선언가능하다.(생성자와 일반 변수 선언 불가능) 메서드의 선언만 가능
	  implements 키워드로 상속 가능하다.
	  </p>
  </div>
</details>
   
### Q10. collection framework
<details>
  <summary>답</summary>
  <div>  
    <p>
      List는 순서가 있는 데이터 집합으로, 데이터 중복이 허용된다. ArrayList, LinkedList등이 있다.
      <hr>
      Set은 순서가 없는 데이터 집합으로, 데이터 중복이 허용되지 않는다. HashSet, TreeSet등이 있다.
      <hr>
      Map은 Key와 Value로 이루어진 데이터 집합으로, Key값의 데이터 중복이 허용되지 않는다. HashMap, TreeMap 등이 있다.
	  </p>
  </div>
</details>

### Q11. OOP의 특징
<details>
  <summary>답</summary>
  <div>  
    <p>
      <h4> 추상화 </h4>
      추상화는 실제 객체들의 공통된 특성을 수집하여 정의하고 제거하는 과정이다. 클래스를 정의하는 것도 일종의 추상화 과정이다.
      <hr>
      <h4> 캡슐화 </h4>
	  <s>캡슐화는 외부에서 내부 데이터 구조를 알 수 없게 만드는 것이다. 캡슐처럼, 내부에 어떤 성분이 있는지, 내부 약의 색은 어떤 것인지 알 수 없게 한다.</s>
	  +캡슐화란 객체의 속성과 기능을 하나로 묶어, 실제 구현 내용 일부를 외부에 감추는 것(정보 은닉)이다.
      <hr>
      <h4> 정보은닉 </h4>
      캡슐화의 가장 중요한 장점으로, 외부에서 내부 데이터를 알수 없게 하는 것으로, 데이터를 보호하기 위한 것이다.
	  +다른 객체에게 자신의 정보를 숨기고 자신의 연산만을 통하여 접근을 허용하는 것이다.
      <hr>
      <h4> 상속 </h4>
      상속은 상위 클래스의 특성을 하위 클래스가 물려받아, 하위 클래스가 상위 클래스의 특성을 모두 가지고 있는 것이다. 이때 상위 클래스는 부모 클래스, 하위 클래스는 자식 클래스라고 한다.<br>
      extends 키워드를 사용하고, 자바는 단일상속만 지원한다......
      <hr>
      <h4> 다형성 </h4>
      다형성은 같은 이름의 메소드를 다른 기능으로 사용할 수 있게 하는 것으로, 오버라이딩과 오버로딩이 있다.<br>
	  </p>
  </div>
</details>

### Q12. OOP의 5대 원칙 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
		  <h4>SOLID</h4>
      <h4> 단일 책임 원칙(SRP, Single responsibility principle) </h4>
      모든 Class는 하나의 책임만 가지며, 그 책임은 완전히 캡슐화되어야 한다는 원칙이다.<br>
		  class는 하나의 기능만 가지며, 그 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어야 한다.
      <hr>
      <h4> 개방/폐쇄 원칙(OCP, Open/Closed Principle) </h4>
	    클래스와 모듈 함수 등의 SW개체는 확장에 대해 열려있어야 하고, 수정에 대해 닫혀있어야 한다는 원칙이다.<br>
		  수정이 일어나더라도 기존 구성요소에서는 수정이 발생하지 않아야 하고, 쉽게 확장이 가능하며 재사용할 수 있어야 한다는 의미이다. 이때, 추상화와 다형성이 중요하다.
      <h4> 리스코프 치환 원칙(LSP, Liskov Substitutions Principle) </h4>
      상속에 대한 개념으로, 부모 클래스가 들어갈 자리에 자식 클래스를 넣어도 잘 구동되어야 한다는 원칙이다.
      <hr>
      <h4> 인터페이스 분리 원칙(ISP, Interface Segregation Principle) </h4>
      한 클래스는 사용하지 않는 인터페이스는 구현하지 말아야 한다.<br>
		  인터페이스들을 구체적이로 작은 단위로 분리하여 꼭 필요한 메서드들만 이용할 수 있게 해야 한다는 의미이다. 이를 통해 시스템의 내부 의존성을 낮출 수 있다.<br>
		  예) 클래스 생성 시 node, run() 함수를 입력으로 넣는 경우 >> run()함수가 필요할 때도 있고, 필요하지 않을 때도 있을 것. 필요하지 않은데 run()함수를 받아 사용해야 하는 경우? >> ISP 위반!
      <hr>
      <h4> 의존성 역전 원칙(DIP, Dependency Inversion Principle) </h4>
      상위 모듈은 하위 모듈에 종속되어서는 안되고, 둘 다 추상화에 의존해야한다는 것과 추상화는 세부사항에 의존하지 않고, 세부사항은 추상화에 의해 달라져댜 한다는 원칙이다. <br>
		  외부에서 의존성을 주입받아야 한다.		  
	  </p>
  </div>
</details>
	 
### Q13. 객체 지향과 절차 지향 차이 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      객체 지향은 각 실제 존재하는 객체를 구체화하여, 관계를 정의하고, 각 객체의 상호작용으로 프로그램이 실행되게 하는 것이다.
      <hr>
      절차 지향은 프로그램이 순서대로 실행되게 하는 것이다.
	  </p>
  </div>
</details>
   
### Q14. getter/setter 사용 이유
<details>
  <summary>답</summary>
  <div>  
    <p>
      캡슐화를 위해 사용한다.<br>
      클래스 내부 필드의 보호를 위해 private 키워드를 사용하여 접근을 제어한다. 이때, 공개 메소드를 통해 내부 필드에 접근할 수 있도록 지정한다. 이 공개 메소드가 getter, setter이다.
	  </p>
  </div>
</details>
   
### Q15. non-static vs static ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      static 키워드는 전역 선언 키워드이다.<br>
      static 키워드로 선언된 필드, 함수는 프로그램이 실행됨과 동시에 생성되며, 클래스 내부의 모든 필드, 함수들에 공유된다.
      <hr>
      static 키워드로 선언되지 않은 멤버는 프로그램 실행 중 생성 코드가 실행될 경우 생성되며, 선언된 클래스의 블록 내부에서만 공유된다.
	  </p>
  </div>
</details>
   
### Q16. final ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      final 키워드는 값을 변경할 수 없게 하는 키워드이다.<br>
      final 키워드를 붙여 선언한 필드는 상수가 되어 사용 중에 값을 변경할 수 없고, 클래스는 상속이 불가능, 메소드는 오버라이딩이 불가능한 상태가 된다.
	  </p>
  </div>
</details>
   
### Q17. Generic
<details>
  <summary>답</summary>
  <div>  
    <p>
      generic은 타입에 대한 일반화를 위한 키워드이다.<br>
      ArrayList<Integer>등으로 선언할 경우 정수형만 담길 수 있는 ArrayList가 되므로, 다양한 종료의 타입으로 사용할 수 있도록 자바의 collection에 ArrayList<E>등으로 선언되어 있다.<br>
      이때 E는 generic 타입으로, 타입을 일반화한 것이다. 해당 위치에는 모든 타입이 올 수 있다.
	  </p>
  </div>
</details>

### Q18. 가비지 컬렉션 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      Garbage Collection은 자바의 메모리를 관리해준다.<br>
      자바는 개발자로 하여금 메모리를 생성하게 하고, 반환하는 부담을 줄였다. 이에 생성된 메모리를 자동으로 제거해주는 역할을 하는 것이 GC이다.<BR>
      GC는 힙 영역에서 활동하며, 불시의 순간에 참조된 변수가 없는 메모리를 제거한다.
	  </p>
  </div>
</details>
   
### Q19. String, StringBuilder, StringBuffer ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      String은 문자열 클래스로, 문자열을 다룬다. 문자열 연산 시 기존 객체에 연산 내용이 적용되지 않고, 연산 결과로 항상 새로운 String 인스턴스가 생성된다.
			+불변의 속성을 가진다.
      <hr>
      StringBuilder는 문자열을 다루는 클래스로, 가변적이기 때문에 문자열 연산 시 기존 객체에 연산 결과가 저장된다.<br>
		  동기화를 지원하지 않기 때문에, 단일 쓰레드/동기화를 고려하지 않는 경우에 적합하다.
      <hr>
      StringBuffer는 문자열을 다루는 클래스로, 가변적이기 때문에 문자열 연산 시 기존 객체에 연산 결과가 저장된다.<br>
		  동기화를 지원하기 때문에 멀티쓰레드 환경에 안전하다.
	  </p>
  </div>
</details>
   
### Q20. ==, equals() 차이
<details>
  <summary>답</summary>
  <div>  
    <p>
      ==는 데이터의 주소값을 비교하는 연산이고, equals()는 데이터 자체의 값을 비교하는 함수이다.<br>
      String 클래스의 경우, ==연산 사용 시 데이터에 담긴 주소 값을 비교하게 되고 equals()함수로 비교 연산 수행 시 데이터 자체에 저장된 문자열을 비교한다.
	  </p>
  </div>
</details>
   
### Q21. 자바 메모리 영역 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
		  <h4>Method Area(Class Area)</h4>
		  모든 스레드가 공유하는 메모리 영역으로, JVM이 코드에서 사용되는 클래스 파일을 클래스 로더로 읽어 클래스, 인터페이스, 메소드, 필드 등의 바이트 코드를 보관한다.<br>
		  전역 변수, static 멤버 변수는 이 영역에 저장되는데, 프로그램이 시작되어 종료될 때까지 메모리에 남아있게 되고, 이를 통해 프로그램이 종료될 때까지 어디서든 사용할 수 있다.
      <hr>
		  <h4>Heap Area</h4>
		  모든 스레드가 공유하는 영역으로, JVM이 관리하는 프로그램에서 데이터를 저장하기 위헤 런타임 시 동적으로 할당하여 사용하는 영역이다.<br> new 키워드로 생성된 객체와 배열을 저장하며, 힙영역에서 생성된 객체, 배열은 스택 영역의 변수나 다른 객체의 필드에서 참조한다.<br>
		  참조하는 변수나 필드가 없으면 GC 대상
      <hr>
		  <h4>Stack</h4>
		  각 스레드마다 하나씩 존재하며, 스레드가 시작될 때 할당된다. 자바에서 메서드를 호출할 때 메서드의 Stack Frame이 저장되는 영역이다.<br>
		  Stack Frame안에는 지역변수, 매개변수, 리턴 데이터 등이 저장된다.<br>
      <hr>
	  </p>
  </div>
</details>

### Q22. 변수 명명법
<details>
  <summary>답</summary>
  <div>  
    <p>
      카멜표기법은 각 단어의 첫 문자만 대문자로 적는 표기법이다. 이때 가장 처음의 문자는 소문자로 시작한다.<br>
      자바 권장 표기법
      예) setKoreanBrand
      <hr>
      스네이크표기법은 단어의 사이를 '_'로 잇는 방법이다. 이때 단어는 소문자로 표기한다.<br>
		  파이썬 권장 표기법
      예) set_korean_brand
      <hr>
	  </p>
  </div>
</details>
