# 자바 면접 질문 리스트 by 지민


### Q1. 자바의 특징과 장단점
<details>
  <summary>답</summary>
  <div>  
    <p>
	    자바는 이식성이 높고, 플랫폼에 종속적이지 않다는 특징을 가지고 있다. 또, 플랫폼에 종속적이지 않기 때문에 웹/모바일/임베디드 등 다양한 분야에 활용될 수 있다.
      <hr>
      장점은 이식성이 높고 JVM으로 실행되기 때문에 플랫폼 종속적이지 않은 점이며, 단점은 JVM으로 실행되기 때문에 실행 속도가 느리다는 점이다.      
	  </p>
  </div>
</details>
    
### Q2. 객체지향 언어의 정의와 장단점
<details>
  <summary>답</summary>
  <div>  
    <p>
      실제 세계의 객체를 정의하고, 그 객체 사이의 상호작용을 통해 프로그램 실행을 작성하도록 하는 언어
      <hr>
      재사용성이 높고, 유지보수성이 좋다는 장점이 있다. 절차지향언어와 비교했을 때 속도가 느리다는 단점이 있다.
	  </p>
  </div>
</details>
   
### Q3. 클래스란
<details>
  <summary>답</summary>
  <div>  
    <p>
      실제 세계에 존재하는 객체의 특성을 정의한 것으로, 객체의 설계도나 틀을 의미한다.
	  </p>
  </div>
</details>
   
### Q4. 객체란
<details>
  <summary>답</summary>
  <div>  
    <p>
      실제 세계에 존재하는 것들이다. TV, 컴퓨터, 책, 건물, 사람 등을 모두 객체라고 할 수 있다.
	  </p>
  </div>
</details>
   
### Q5. 생성자란 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      객체를 생성하기 위한 초기화 함수
	  </p>
  </div>
</details>
   
### Q6. 지역변수, 인스턴스 변수 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      지역 변수는 블록 내에서 선언된 변수로, 블록 내부에서만 유효하다.
	  </p>
  </div>
</details>
   
### Q7. 오버라이딩, 오버로딩의 차이
<details>
  <summary>답</summary>
  <div>  
    <p>
      오버라이딩은 상속 관계에서 부모의 메소드를 자식의 특성에 맞게 재정의 하는 것이다.<br>
      메소드의 이름, 리턴 타입, 매개변수 {개수, 타입, 순서)가 일치해야 하며,
      부모 메소드보다 접근 지정자는 크거나 같아야 하고, 부모보다 큰 예외는 처리할 수 없다.
      <hr>
      오버로딩은 이름이 같은 메소드를 다르게 기능하도록 여러 개 정의하는 것이다.<br>
      메소드의 이름이 같고, 매개변수가 다르면 된다. 단, 매개변수가 같고 리턴타입이 다른 경우는 오버로딩이 되지 않는다.
	  </p>
  </div>
</details>
   
### Q8. 접근제어자 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      <h4> private </h4>
      private는 선언된 클래스 내부에서만 접근할 수 있다.
      <hr>
      <h4> protected </h4>
      protected는 선언된 클래스의 동일 패키지 내 다른 클래스에서도 접근할 수 있다. 타 패키지이더라도, 상속받은 자식 클래스라면 접근할 수 있다.
      <hr>
      <h4> default </h4>
      default는 선언된 클래스의 동일 패키지 내 다른 클래스에서도 접근할 수 있다.
      <hr>
      <h4> public </h4>
      public은 선언된 클래스 이외의 곳에서 모두 접근할 수 있다.
	  </p>
  </div>
</details>
   
### Q9. 추상클래스, 인터페이스의 차이 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      추상클래스는 멤버 변수와 멤버 함수가 모두 선언만 되고 구현되지 않은 클래스이다. abstract 키워드를 사용하며, 클래스의 구현 틀을 지정하기 위해 사용한다.
      <hr>
      인터페이스는 멤버 변수와 멤버 함수가 모두 선언만 되고 구현되지 않은 클래스이다. interface 키워드로 정의하며, 클래스의 구현 구조를 지정하기 위해 사용한다.<br>
      인터페이스를 상속받은 클래스의 경우, 선언된 모든 메소드를 오버라이딩하여 구현해야한다.
	  </p>
  </div>
</details>
   
### Q10. collection framework
<details>
  <summary>답</summary>
  <div>  
    <p>
      List는 순서가 있는 데이터 집합으로, 데이터 중복이 허용된다. ArrayList, LinkedList등이 있다.
      <hr>
      Set은 순서가 없는 데이터 집합으로, 데이터 중복이 허용되지 않는다. HashSet, TreeSet등이 있다.
      <hr>
      Map은 Key와 Value로 이루어진 데이터 집합으로, Key값의 데이터 중복이 허용되지 않는다. HashMap, TreeMap 등이 있다.
	  </p>
  </div>
</details>

### Q11. OOP의 특징
<details>
  <summary>답</summary>
  <div>  
    <p>
      <h4> 추상화 </h4>
      추상화는 실제 객체들의 공통된 특성을 수집하여 정의하고 제거하는 과정이다. 클래스를 정의하는 것도 일종의 추상화 과정이다.
      <hr>
      <h4> 캡슐화 </h4>
      캡슐화는 외부에서 내부 데이터 구조를 알 수 없게 만드는 것이다. 캡슐처럼, 내부에 어떤 성분이 있는지, 내부 약의 색은 어떤 것인지 알 수 없게 한다.
      <hr>
      <h4> 정보은닉 </h4>
      캡슐화의 깊은 의미로, 외부에서 내부 데이터를 알수 없게 하는 것으로, 데이터를 보호하기 위한 것이다.
      <hr>
      <h4> 상속 </h4>
      상속은 기존 클래스의 필드, 메소드 등을 새로 만들어질 클래스가 모두 이어 받는 것이다. 이때 기존 클래스는 부모 클래스, 새로 만들어질 클래스는 자식 클래스라고 한다.<br>
      기존 코드를 재사용하여 코드 길이를 줄이고, 프로그램 코드의 재사용성을 높인다.
      <hr>
      <h4> 다형성 </h4>
      다형성은 같은 이름의 메소드를 다른 기능으로 사용할 수 있게 하는 것으로, 오버라이딩과 오버로딩이 있다.<br>
	  </p>
  </div>
</details>

### Q12. OOP의 5대 원칙 ❓
   
### Q13. 객체 지향과 절차 지향 차이 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      객체 지향은 각 실제 존재하는 물체를 객체로 정의하여, 각 객체의 상호작용으로 프로그램이 실행되게 하는 것이다.
      <hr>
      절차 지향은 프로그램이 순서대로 실행되게 하는 것이다.
	  </p>
  </div>
</details>
   
### Q14. getter/setter 사용 이유
<details>
  <summary>답</summary>
  <div>  
    <p>
      캡슐화를 위해 사용한다.<br>
      클래스 내부 필드의 보호를 위해 private 키워드를 사용하여 접근을 제어한다. 이때, 공개 메소드를 통해 내부 필드에 접근할 수 있도록 지정한다. 이 공개 메소드가 getter, setter이다.
	  </p>
  </div>
</details>
   
### Q15. non-static vs static ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      static 키워드는 전역 선언 키워드이다.<br>
      static 키워드로 선언된 필드, 함수는 프로그램이 실행됨과 동시에 생성되며, 클래스 내부의 모든 필드, 함수들에 공유된다.
      <hr>
      static 키워드로 선언되지 않은 멤버는 프로그램 실행 중 생성 코드가 실행될 경우 생성되며, 선언된 클래스의 블록 내부에서만 공유된다.
	  </p>
  </div>
</details>
   
### Q16. final ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      final 키워드는 값을 변경할 수 없게 하는 키워드이다.<br>
      final 키워드를 붙여 선언한 필드는 상수가 되어 값을 변경할 수 없다.
	  </p>
  </div>
</details>
   
### Q17. Generic
<details>
  <summary>답</summary>
  <div>  
    <p>
      generic은 변수에 대한 일반화를 위한 키워드이다.<br>
      ArrayList<Integer>등으로 선언할 경우 정수형만 담길 수 있는 ArrayList가 되므로, 어떤 변수로도 선언하여 변환할 수 있도록 자바의 collection에 ArrayList<E>등으로 선언되어 있다.<br>
      이때 E가 generic 변수로, 변수를 일반화한 것이다. 해당 위치에는 모든 변수 타입이 올 수 있다.
	  </p>
  </div>
</details>

### Q18. 가비지 컬렉션 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      Garbage Collection은 자바의 메모리를 관리해준다.<br>
      자바는 개발자로 하여금 메모리를 생성하게 하고, 반환하는 부담을 줄였다. 이에 생성된 메모리를 자동으로 제거해주는 역할을 하는 것이 GC이다.<BR>
      GC는 힙 영역에서 활동하며, 불시의 순간에 참조된 변수가 없는 메모리를 제거한다.
	  </p>
  </div>
</details>
   
### Q19. String, StringBuilder, StringBuffer ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      String은 문자열 클래스로, 문자열을 다룬다. 문자열 연산 시 기존 객체에 연산 내용이 적용되지 않고, 연산 결과로 항상 새로 클래스가 생성된다.
      <hr>
      StringBuilder는 문자열을 다루는 클래스로, 가변적이기 때문에 문자열 연산 시 기존 객체에 추가로 연산 결과가 저장된다.
      <hr>
      StringBuffer는 문자열을 다루는 클래스로, 어쩌구...
	  </p>
  </div>
</details>
   
### Q20. ==, equals() 차이
<details>
  <summary>답</summary>
  <div>  
    <p>
      ==는 데이터의 값을 비교하는 연산이고, equals()함수는 데이터의 주소에 저장된 값을 비교하는 연산이다.<br>
      String 클래스의 경우, ==연산 사용 시 클래스에 담긴 주소 값을 비교하게 되고 equals()함수로 비교 연산 수행 시 클래스 주소에 저장된 문자열을 비교한다.
	  </p>
  </div>
</details>
   
### Q21. 자바 메모리 영역 ❓
<details>
  <summary>답</summary>
  <div>  
    <p>
      Heap
      <hr>
      Stack
      <hr>
	  </p>
  </div>
</details>

### Q22. 변수 명명법
<details>
  <summary>답</summary>
  <div>  
    <p>
      카멜표기법은 단어의 첫 시작만 대문자로 적는 표기법이다. 이때 가장 처음의 문자 시작은 소문자로 시작한다.<br>
      예) setKoreanBrand
      <hr>
      스네이크표기법은 단어의 사이를 '_'로 잇는 방법이다. 이때 단어는 소문자로 표기한다.<br>
      예) set_korean_brand
      <hr>
	  </p>
  </div>
</details>
